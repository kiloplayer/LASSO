n = 200
p = 80
k = 20
lambda = 10 ^ seq(log10(0.1), log10(10), length.out = 40)
D = matrix(0, ncol = p + 1, nrow = p)
for (i in 1:p) {
if (i == 1) {
next
} else {
D[i, i] = -1
D[i, i + 1] = 1
}
}
param = data.frame(lambda = lambda)
set.seed(1)
# simulation
beta0 = rnorm(p, mean = 0, sd = 1)
beta0[(k + 1):p] = 0
beta0 = sample(beta0) # shuffle
beta = cumsum(beta0)
beta = (beta - mean(beta)) / sd(beta)
rm(beta0)
X = matrix(rnorm(n * p, mean = 0, sd = sqrt(1 / k)), ncol = p)
intercept = 1
sigma = rnorm(n, mean = 0, sd = 0.5)
y = intercept + X %*% beta + sigma
# true leave-one-out
y.loo = matrix(ncol = dim(param)[1], nrow = n)
starttime = proc.time() # count time
no_cores = detectCores() - 1
cl = makeCluster(no_cores)
registerDoParallel(cl)
for (i in 1:n) {
# do leave one out prediction
y.temp <-
foreach(
k = 1:length(lambda),
.combine = cbind,
.packages = 'CVXR'
) %dopar%
GenLASSO_LOO(X, y, i, lambda[k], intercept = TRUE)
# save the prediction value
y.loo[i,] = y.temp
# print middle result
if (i %% 10 == 0)
print(
paste(
i,
"samples have beed calculated.",
"On average, every sample needs",
round((proc.time() - starttime)[3] / i, 2),
"seconds."
)
)
}
stopCluster(cl)
# true leave-one-out risk estimate
risk.loo = 1 / n *
colSums((y.loo - matrix(rep(y, dim(
param
)[1]),
ncol = dim(param)[1])) ^ 2)
# record the result
result = cbind(param, risk.loo)
# save the data
save(result, y.loo,
file = "RData/GenLASSO_LOO.RData")
# approximate leave-one-out
load('RData/GenLASSO_LOO.RData')
y.alo = matrix(ncol = dim(param)[1], nrow = n)
starttime = proc.time() # count time
y.alo <- foreach(k = 1:length(lambda),
.combine = cbind,
.packages = 'CVXR') %do%
GenLASSO_ALO(X, y, D, lambda[k], intercept = TRUE)
# true leave-one-out risk estimate
risk.alo = 1 / n * colSums((y.alo -
matrix(rep(y, dim(
param
)[1]), ncol = dim(param)[1])) ^ 2)
# record the result
result = cbind(result, risk.alo)
# save the data
save(result, y.loo, y.alo,
file = "RData/GenLASSO_ALO.RData")
# plot
load("RData/GenLASSO_ALO.RData")
p = ggplot(result) +
geom_line(aes(x = log10(lambda), y = risk.loo), lty = 2) +
geom_line(aes(x = log10(lambda), y = risk.alo), col = "red", lty = 2)
bmp("figure/GenLASSO_with_Intercept.bmp",
width = 1280,
height = 720)
p
dev.off()
p
intercept=TRUE
if (intercept) {
X = cbind(1, X)
}
# find out the dimension of X
n = dim(X)[1]
p = dim(X)[2]
# fit the primal optimization problem to find beta
beta = Variable(p)
objective = Minimize(1 / 2 * sum_squares(y - X %*% beta) +
lambda * p_norm(D %*% beta, 1))
problem = Problem(objective)
result = solve(problem)
beta = result$getValue(beta)
lambda=lambda[1]
beta = Variable(p)
objective = Minimize(1 / 2 * sum_squares(y - X %*% beta) +
lambda * p_norm(D %*% beta, 1))
problem = Problem(objective)
result = solve(problem)
beta = result$getValue(beta)
# fit the dual optimization problem to find u
theta = Variable(n)
u = Variable(dim(D)[1])
objective = Minimize(1 / 2 * sum_squares(theta - y))
constraints = list(t(D) %*% u == t(X) %*% theta, abs(u) <= lambda)
problem = Problem(objective, constraints)
result = solve(problem)
u = result$getValue(u)
theta=result$getDualValue()
# fit the dual optimization problem to find u
theta = Variable(n)
u = Variable(dim(D)[1])
objective = Minimize(1 / 2 * sum_squares(theta - y))
constraints = list(t(D) %*% u == t(X) %*% theta, abs(u) <= lambda)
problem = Problem(objective, constraints)
result = solve(problem)
u = result$getValue(theta)
# fit the dual optimization problem to find u
theta = Variable(n)
u = Variable(dim(D)[1])
objective = Minimize(1 / 2 * sum_squares(theta - y))
constraints = list(t(D) %*% u == t(X) %*% theta, abs(u) <= lambda)
problem = Problem(objective, constraints)
result = solve(problem)
u = result$getValue(u)
theta=result$getValue(theta)
plot(theta,y-X%*%beta)
sum(abs(theta-y+X%*%beta))
y_hat=X%*%beta
mE=which(abs(abs(u)-lambda)>=E-8)
mE=which(abs(abs(u)-lambda)>=1E-8)
mE
plot(u)
plot(abs(u)-lambda)
max(abs(u)-lambda)
sum(abs(u)-lambda>-1E-6)
sum(abs(u)-lambda>-1E-5)
sum(abs(u)-lambda>-1E-4)
sum(abs(u)-lambda>-1E-3)
sum(abs(u)-lambda>-1E-2)
sum(abs(u)-lambda>-1E-1)
plot((abs(u)-lambda)[abs(u)-lambda>-1E-1])
plot((abs(u)-lambda)[abs(u)-lambda>-1E-2])
plot((abs(u)-lambda)[abs(u)-lambda>-1E-3])
plot((abs(u)-lambda)[abs(u)-lambda>-1E-4])
plot((abs(u)-lambda)[abs(u)-lambda>-1E-5])
plot((abs(u)-lambda)[abs(u)-lambda>-1E-3])
plot((abs(u)-lambda)[abs(u)-lambda>-1E-2])
plot((abs(u)-lambda)[abs(u)-lambda>-1E-4])
plot((abs(u)-lambda)[abs(u)-lambda>-1E-6])
plot((abs(u)-lambda)[abs(u)-lambda>-1E-5])
plot((abs(u)-lambda)[abs(u)-lambda>-1E-4])
# Generalized_LASSO -------------------------------------------------------
setwd("E:\\Columbia_University\\Internship\\R_File\\LASSO\\")
library(glmnet)
library(ggplot2)
library(Rcpp)
library(CVXR)
library(MASS)
library(foreach)
library(doParallel)
sourceCpp("src/ALO_Primal.cpp")
source("R/GenLASSO_Functions.R")
# Generalized LASSO with Intercept ----------------------------------------
# parameters
n = 200
p = 80
k = 20
lambda = 10 ^ seq(log10(0.1), log10(10), length.out = 40)
D = matrix(0, ncol = p + 1, nrow = p)
for (i in 1:p) {
if (i == 1) {
next
} else {
D[i, i] = -1
D[i, i + 1] = 1
}
}
param = data.frame(lambda = lambda)
set.seed(1)
# simulation
beta0 = rnorm(p, mean = 0, sd = 1)
beta0[(k + 1):p] = 0
beta0 = sample(beta0) # shuffle
beta = cumsum(beta0)
beta = (beta - mean(beta)) / sd(beta)
rm(beta0)
X = matrix(rnorm(n * p, mean = 0, sd = sqrt(1 / k)), ncol = p)
intercept = 1
sigma = rnorm(n, mean = 0, sd = 0.5)
y = intercept + X %*% beta + sigma
# true leave-one-out
y.loo = matrix(ncol = dim(param)[1], nrow = n)
starttime = proc.time() # count time
no_cores = detectCores() - 1
cl = makeCluster(no_cores)
registerDoParallel(cl)
for (i in 1:n) {
# do leave one out prediction
y.temp <-
foreach(
k = 1:length(lambda),
.combine = cbind,
.packages = 'CVXR'
) %dopar%
GenLASSO_LOO(X, y, i, lambda[k], intercept = TRUE)
# save the prediction value
y.loo[i,] = y.temp
# print middle result
if (i %% 10 == 0)
print(
paste(
i,
"samples have beed calculated.",
"On average, every sample needs",
round((proc.time() - starttime)[3] / i, 2),
"seconds."
)
)
}
# Generalized_LASSO -------------------------------------------------------
setwd("E:\\Columbia_University\\Internship\\R_File\\LASSO\\")
library(glmnet)
library(ggplot2)
library(Rcpp)
library(CVXR)
library(MASS)
library(foreach)
library(doParallel)
sourceCpp("src/ALO_Primal.cpp")
source("R/GenLASSO_Functions.R")
# Generalized LASSO with Intercept ----------------------------------------
# parameters
n = 200
p = 80
k = 20
lambda = 10 ^ seq(log10(0.1), log10(10), length.out = 40)
D = matrix(0, ncol = p + 1, nrow = p)
for (i in 1:p) {
if (i == 1) {
next
} else {
D[i, i] = -1
D[i, i + 1] = 1
}
}
param = data.frame(lambda = lambda)
set.seed(1)
# simulation
beta0 = rnorm(p, mean = 0, sd = 1)
beta0[(k + 1):p] = 0
beta0 = sample(beta0) # shuffle
beta = cumsum(beta0)
beta = (beta - mean(beta)) / sd(beta)
rm(beta0)
X = matrix(rnorm(n * p, mean = 0, sd = sqrt(1 / k)), ncol = p)
intercept = 1
sigma = rnorm(n, mean = 0, sd = 0.5)
y = intercept + X %*% beta + sigma
# approximate leave-one-out
load('RData/GenLASSO_LOO.RData')
y.alo = matrix(ncol = dim(param)[1], nrow = n)
starttime = proc.time() # count time
y.alo <- foreach(k = 1:length(lambda),
.combine = cbind,
.packages = 'CVXR') %do%
GenLASSO_ALO(X, y, D, lambda[k], intercept = TRUE)
# true leave-one-out risk estimate
risk.alo = 1 / n * colSums((y.alo -
matrix(rep(y, dim(
param
)[1]), ncol = dim(param)[1])) ^ 2)
# record the result
result = cbind(result, risk.alo)
# save the data
save(result, y.loo, y.alo,
file = "RData/GenLASSO_ALO.RData")
# plot
load("RData/GenLASSO_ALO.RData")
p = ggplot(result) +
geom_line(aes(x = log10(lambda), y = risk.loo), lty = 2) +
geom_line(aes(x = log10(lambda), y = risk.alo), col = "red", lty = 2)
bmp("figure/GenLASSO_with_Intercept.bmp",
width = 1280,
height = 720)
p
dev.off()
p
# approximate leave-one-out
load('RData/GenLASSO_LOO.RData')
y.alo = matrix(ncol = dim(param)[1], nrow = n)
starttime = proc.time() # count time
y.alo <- foreach(k = 1:length(lambda),
.combine = cbind,
.packages = 'CVXR') %do%
GenLASSO_ALO(X, y, D, lambda[k], intercept = TRUE)
# true leave-one-out risk estimate
risk.alo = 1 / n * colSums((y.alo -
matrix(rep(y, dim(
param
)[1]), ncol = dim(param)[1])) ^ 2)
# record the result
result = cbind(result, risk.alo)
# save the data
save(result, y.loo, y.alo,
file = "RData/GenLASSO_ALO.RData")
# plot
load("RData/GenLASSO_ALO.RData")
p = ggplot(result) +
geom_line(aes(x = log10(lambda), y = risk.loo), lty = 2) +
geom_line(aes(x = log10(lambda), y = risk.alo), col = "red", lty = 2)
bmp("figure/GenLASSO_with_Intercept.bmp",
width = 1280,
height = 720)
p
dev.off()
# Generalized_LASSO -------------------------------------------------------
setwd("E:\\Columbia_University\\Internship\\R_File\\LASSO\\")
library(glmnet)
library(ggplot2)
library(Rcpp)
library(CVXR)
library(MASS)
library(foreach)
library(doParallel)
sourceCpp("src/ALO_Primal.cpp")
source("R/GenLASSO_Functions.R")
# approximate leave-one-out
load('RData/GenLASSO_LOO.RData')
y.alo = matrix(ncol = dim(param)[1], nrow = n)
starttime = proc.time() # count time
y.alo <- foreach(k = 1:length(lambda),
.combine = cbind,
.packages = 'CVXR') %do%
GenLASSO_ALO(X, y, D, lambda[k], intercept = TRUE)
# true leave-one-out risk estimate
risk.alo = 1 / n * colSums((y.alo -
matrix(rep(y, dim(
param
)[1]), ncol = dim(param)[1])) ^ 2)
# record the result
result = cbind(result, risk.alo)
# save the data
save(result, y.loo, y.alo,
file = "RData/GenLASSO_ALO.RData")
# plot
load("RData/GenLASSO_ALO.RData")
p = ggplot(result) +
geom_line(aes(x = log10(lambda), y = risk.loo), lty = 2) +
geom_line(aes(x = log10(lambda), y = risk.alo), col = "red", lty = 2)
bmp("figure/GenLASSO_with_Intercept.bmp",
width = 1280,
height = 720)
p
dev.off()
p
source("R/GenLASSO_Functions.R")
# approximate leave-one-out
load('RData/GenLASSO_LOO.RData')
y.alo = matrix(ncol = dim(param)[1], nrow = n)
starttime = proc.time() # count time
y.alo <- foreach(k = 1:length(lambda),
.combine = cbind,
.packages = 'CVXR') %do%
GenLASSO_ALO(X, y, D, lambda[k], intercept = TRUE)
# true leave-one-out risk estimate
risk.alo = 1 / n * colSums((y.alo -
matrix(rep(y, dim(
param
)[1]), ncol = dim(param)[1])) ^ 2)
# record the result
result = cbind(result, risk.alo)
# save the data
save(result, y.loo, y.alo,
file = "RData/GenLASSO_ALO.RData")
# plot
load("RData/GenLASSO_ALO.RData")
p = ggplot(result) +
geom_line(aes(x = log10(lambda), y = risk.loo), lty = 2) +
geom_line(aes(x = log10(lambda), y = risk.alo), col = "red", lty = 2)
bmp("figure/GenLASSO_with_Intercept.bmp",
width = 1280,
height = 720)
p
dev.off()
p
# Generalized_LASSO -------------------------------------------------------
setwd("E:\\Columbia_University\\Internship\\R_File\\LASSO\\")
library(glmnet)
library(ggplot2)
library(Rcpp)
library(CVXR)
library(MASS)
library(foreach)
library(doParallel)
sourceCpp("src/ALO_Primal.cpp")
source("R/GenLASSO_Functions.R")
# Generalized LASSO with Intercept ----------------------------------------
# parameters
n = 200
p = 400
k = 20
lambda = 10 ^ seq(log10(0.1), log10(10), length.out = 40)
D = matrix(0, ncol = p + 1, nrow = p)
for (i in 1:p) {
if (i == 1) {
next
} else {
D[i, i] = -1
D[i, i + 1] = 1
}
}
param = data.frame(lambda = lambda)
set.seed(1)
# simulation
beta0 = rnorm(p, mean = 0, sd = 1)
beta0[(k + 1):p] = 0
beta0 = sample(beta0) # shuffle
beta = cumsum(beta0)
beta = (beta - mean(beta)) / sd(beta)
rm(beta0)
X = matrix(rnorm(n * p, mean = 0, sd = sqrt(1 / k)), ncol = p)
intercept = 1
sigma = rnorm(n, mean = 0, sd = 0.5)
y = intercept + X %*% beta + sigma
# true leave-one-out
y.loo = matrix(ncol = dim(param)[1], nrow = n)
starttime = proc.time() # count time
no_cores = detectCores() - 1
cl = makeCluster(no_cores)
registerDoParallel(cl)
for (i in 1:n) {
# do leave one out prediction
y.temp <-
foreach(
k = 1:length(lambda),
.combine = cbind,
.packages = 'CVXR'
) %dopar%
GenLASSO_LOO(X, y, i, lambda[k], intercept = TRUE)
# save the prediction value
y.loo[i,] = y.temp
# print middle result
if (i %% 10 == 0)
print(
paste(
i,
"samples have beed calculated.",
"On average, every sample needs",
round((proc.time() - starttime)[3] / i, 2),
"seconds."
)
)
}
stopCluster(cl)
# true leave-one-out risk estimate
risk.loo = 1 / n *
colSums((y.loo - matrix(rep(y, dim(
param
)[1]),
ncol = dim(param)[1])) ^ 2)
# record the result
result = cbind(param, risk.loo)
# save the data
save(result, y.loo,
file = "RData/GenLASSO_LOO.RData")
# approximate leave-one-out
load('RData/GenLASSO_LOO.RData')
y.alo = matrix(ncol = dim(param)[1], nrow = n)
starttime = proc.time() # count time
y.alo <- foreach(k = 1:length(lambda),
.combine = cbind,
.packages = 'CVXR') %do%
GenLASSO_ALO(X, y, D, lambda[k], intercept = TRUE)
# true leave-one-out risk estimate
risk.alo = 1 / n * colSums((y.alo -
matrix(rep(y, dim(
param
)[1]), ncol = dim(param)[1])) ^ 2)
# record the result
result = cbind(result, risk.alo)
# save the data
save(result, y.loo, y.alo,
file = "RData/GenLASSO_ALO.RData")
# plot
load("RData/GenLASSO_ALO.RData")
p = ggplot(result) +
geom_line(aes(x = log10(lambda), y = risk.loo), lty = 2) +
geom_line(aes(x = log10(lambda), y = risk.alo), col = "red", lty = 2)
bmp("figure/GenLASSO_with_Intercept.bmp",
width = 1280,
height = 720)
p
dev.off()
p
